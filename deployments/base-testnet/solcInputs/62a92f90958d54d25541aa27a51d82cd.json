{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_router;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_router = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return i_router address\n  function getRouter() public view returns (address) {\n    return address(i_router);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns guaranteed execution fee for the specified message\n  /// delivery to destination chain\n  /// @dev returns 0 fee on invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // extraArgs will evolve to support new features\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\n    bool strict; // See strict sequencing details below.\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n    * @dev Returns true if this contract implements the interface defined by\n    * `interfaceId`. See the corresponding\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n    * to learn more about how these ids are created.\n    *\n    * This function call must use less than 30 000 gas.\n    */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/adapters/Token6022BridgeAdapterCCIP.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { CCIPReceiver } from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport { IRouterClient } from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport { Client } from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\n\nimport { IToken6022BridgeCore } from \"../interfaces/IToken6022BridgeCore/IToken6022BridgeCore.sol\";\nimport { IToken6022BridgeCoreOwnable } from \"../interfaces/IToken6022BridgeCore/IToken6022BridgeCoreOwnable.sol\";\nimport { IToken6022BridgeAdapterCCIP } from \"../interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIP.sol\";\n\ncontract Token6022BridgeAdapterCCIP is CCIPReceiver, IToken6022BridgeAdapterCCIP {\n    IToken6022BridgeCore public immutable core;\n\n    mapping(uint64 chainSelector => bytes peer) public ccipPeers;\n    mapping(uint64 chainSelector => bytes extraArgs) public ccipExtraArgs;\n\n    modifier onlyCoreOwner() {\n        address coreOwner = IToken6022BridgeCoreOwnable(address(core)).owner();\n        if (msg.sender != coreOwner) {\n            revert OnlyCoreOwner(msg.sender, coreOwner);\n        }\n        _;\n    }\n\n    /// @notice Initializes a CCIP bridge adapter.\n    /// @param _core Bridge core contract.\n    /// @param _ccipRouter Chainlink CCIP router address.\n    constructor(address _core, address _ccipRouter) CCIPReceiver(_ccipRouter) {\n        if (_core == address(0)) {\n            revert InvalidCore(_core);\n        }\n\n        core = IToken6022BridgeCore(_core);\n    }\n\n    /// @notice Sets the trusted remote CCIP adapter for a chain selector.\n    /// @param _chainSelector CCIP chain selector.\n    /// @param _peer Trusted remote adapter.\n    function setCcipPeer(uint64 _chainSelector, bytes calldata _peer) external onlyCoreOwner {\n        ccipPeers[_chainSelector] = _peer;\n        emit CcipPeerSet(_chainSelector, _peer);\n    }\n\n    /// @notice Sets CCIP extra arguments for a destination chain selector.\n    /// @param _chainSelector CCIP destination chain selector.\n    /// @param _extraArgs Encoded CCIP execution options.\n    function setCcipExtraArgs(uint64 _chainSelector, bytes calldata _extraArgs) external onlyCoreOwner {\n        ccipExtraArgs[_chainSelector] = _extraArgs;\n        emit CcipExtraArgsSet(_chainSelector, _extraArgs);\n    }\n\n    /// @notice Quotes native fee required to send a bridge message through CCIP.\n    /// @param _dstChainSelector Destination CCIP chain selector.\n    /// @param _to Recipient on destination chain.\n    /// @param _amount Token amount to bridge.\n    /// @param _userTransferId User-provided transfer identifier entropy.\n    /// @return fee Required native fee.\n    function quoteCcipSend(\n        uint64 _dstChainSelector,\n        address _to,\n        uint256 _amount,\n        bytes32 _userTransferId\n    ) external view returns (uint256 fee) {\n        bytes32 transferId = _deriveTransferId(msg.sender, _dstChainSelector, _to, _amount, _userTransferId);\n\n        return IRouterClient(getRouter()).getFee(\n            _dstChainSelector, _buildCcipMessage(_dstChainSelector, _to, _amount, transferId)\n        );\n    }\n\n    /// @notice Bridges tokens through CCIP to the configured remote peer.\n    /// @param _dstChainSelector Destination CCIP chain selector.\n    /// @param _to Recipient on destination chain.\n    /// @param _amount Token amount to bridge.\n    /// @param _userTransferId User-provided transfer identifier entropy.\n    /// @return messageId CCIP message identifier.\n    function sendWithCcip(\n        uint64 _dstChainSelector,\n        address _to,\n        uint256 _amount,\n        bytes32 _userTransferId\n    ) external payable returns (bytes32 messageId) {\n        if (_to == address(0)) {\n            revert InvalidRecipient(_to);\n        }\n\n        if (ccipPeers[_dstChainSelector].length == 0) {\n            revert MissingCcipPeer(_dstChainSelector);\n        }\n\n        bytes32 transferId = _deriveTransferId(msg.sender, _dstChainSelector, _to, _amount, _userTransferId);\n\n        core.bridgeOut(msg.sender, _amount, transferId);\n\n        Client.EVM2AnyMessage memory message = _buildCcipMessage(_dstChainSelector, _to, _amount, transferId);\n\n        uint256 fee = IRouterClient(getRouter()).getFee(_dstChainSelector, message);\n        if (msg.value < fee) {\n            revert InvalidNativeFee(msg.value, fee);\n        }\n\n        messageId = IRouterClient(getRouter()).ccipSend{ value: fee }(_dstChainSelector, message);\n\n        uint256 refund = msg.value - fee;\n        if (refund != 0) {\n            (bool success,) = payable(msg.sender).call{ value: refund }(\"\");\n            if (!success) {\n                revert NativeRefundFailed(msg.sender, refund);\n            }\n        }\n\n        emit CcipSend(_dstChainSelector, messageId, transferId, msg.sender, _to, _amount);\n    }\n\n    /// @notice Handles inbound CCIP messages and forwards payload to core bridge logic.\n    /// @param _message Incoming CCIP message.\n    function _ccipReceive(Client.Any2EVMMessage memory _message) internal override {\n        // Belongs to native CCIP token transfer payload, which is not supported by this adapter\n        if (_message.destTokenAmounts.length != 0) {\n            revert UnsupportedCcipTokenPayload(_message.destTokenAmounts.length);\n        }\n\n        bytes memory sourceSender = _message.sender;\n        bytes memory expectedPeer = ccipPeers[_message.sourceChainSelector];\n\n        if (expectedPeer.length == 0 || keccak256(sourceSender) != keccak256(expectedPeer)) {\n            revert InvalidCcipPeer(_message.sourceChainSelector, sourceSender);\n        }\n\n        (bytes32 transferId, address to, uint256 amount) = abi.decode(_message.data, (bytes32, address, uint256));\n\n        core.bridgeIn(to, amount, transferId, _message.messageId);\n\n        emit CcipReceive(_message.sourceChainSelector, _message.messageId, transferId, to, amount);\n    }\n\n    /// @notice Builds a CCIP message for bridge transfer payload.\n    /// @param _dstChainSelector Destination CCIP chain selector.\n    /// @param _to Recipient on destination chain.\n    /// @param _amount Token amount to bridge.\n    /// @param _transferId Cross-chain transfer identifier.\n    /// @return message Encoded CCIP message.\n    function _buildCcipMessage(\n        uint64 _dstChainSelector,\n        address _to,\n        uint256 _amount,\n        bytes32 _transferId\n    ) internal view returns (Client.EVM2AnyMessage memory message) {\n        message = Client.EVM2AnyMessage({\n            receiver: ccipPeers[_dstChainSelector],\n            data: abi.encode(_transferId, _to, _amount),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            feeToken: address(0),\n            extraArgs: ccipExtraArgs[_dstChainSelector]\n        });\n    }\n\n    /// @notice Derives a collision-resistant transfer identifier from caller and route metadata.\n    /// @dev User-provided transfer id is treated as entropy and namespaced by adapter + sender + destination + payload.\n    function _deriveTransferId(\n        address _sender,\n        uint64 _dstChainSelector,\n        address _to,\n        uint256 _amount,\n        bytes32 _userTransferId\n    ) internal view returns (bytes32 transferId) {\n        transferId = keccak256(\n            abi.encode(address(this), _sender, _dstChainSelector, _to, _amount, _userTransferId)\n        );\n    }\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIP.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { IToken6022BridgeAdapterCCIPErrors } from \"./IToken6022BridgeAdapterCCIPErrors.sol\";\nimport { IToken6022BridgeAdapterCCIPEvents } from \"./IToken6022BridgeAdapterCCIPEvents.sol\";\nimport { IToken6022BridgeAdapterCCIPStates } from \"./IToken6022BridgeAdapterCCIPStates.sol\";\nimport { IToken6022BridgeAdapterCCIPOwnerActions } from \"./IToken6022BridgeAdapterCCIPOwnerActions.sol\";\nimport { IToken6022BridgeAdapterCCIPActions } from \"./IToken6022BridgeAdapterCCIPActions.sol\";\n\ninterface IToken6022BridgeAdapterCCIP is\n    IToken6022BridgeAdapterCCIPErrors,\n    IToken6022BridgeAdapterCCIPEvents,\n    IToken6022BridgeAdapterCCIPStates,\n    IToken6022BridgeAdapterCCIPOwnerActions,\n    IToken6022BridgeAdapterCCIPActions\n{\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIPActions.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeAdapterCCIPActions {\n    /// @notice Quotes native fee to send a bridge message through CCIP.\n    /// @param dstChainSelector Destination CCIP chain selector.\n    /// @param to Recipient on destination chain.\n    /// @param amount Token amount to bridge.\n    /// @param userTransferId User-provided transfer identifier entropy.\n    /// @return fee Required native fee.\n    function quoteCcipSend(\n        uint64 dstChainSelector,\n        address to,\n        uint256 amount,\n        bytes32 userTransferId\n    ) external view returns (uint256 fee);\n\n    /// @notice Bridges tokens through CCIP to the configured remote peer.\n    /// @param dstChainSelector Destination CCIP chain selector.\n    /// @param to Recipient on destination chain.\n    /// @param amount Token amount to bridge.\n    /// @param userTransferId User-provided transfer identifier entropy.\n    /// @return messageId CCIP message identifier.\n    function sendWithCcip(\n        uint64 dstChainSelector,\n        address to,\n        uint256 amount,\n        bytes32 userTransferId\n    ) external payable returns (bytes32 messageId);\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIPErrors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeAdapterCCIPErrors {\n    /// @notice Thrown when caller is not the current core owner.\n    /// @param caller Unauthorized caller.\n    /// @param expectedOwner Current bridge core owner.\n    error OnlyCoreOwner(address caller, address expectedOwner);\n\n    /// @notice Thrown when no trusted remote CCIP peer is configured for destination chain.\n    /// @param chainSelector Destination CCIP chain selector.\n    error MissingCcipPeer(uint64 chainSelector);\n\n    /// @notice Thrown when an inbound message sender does not match configured peer.\n    /// @param chainSelector Source CCIP chain selector.\n    /// @param sender Raw CCIP sender bytes from the message.\n    error InvalidCcipPeer(uint64 chainSelector, bytes sender);\n\n    /// @notice Thrown when deploying with a zero core address.\n    /// @param core Invalid core address.\n    error InvalidCore(address core);\n\n    /// @notice Thrown when destination recipient is invalid.\n    /// @param recipient Invalid recipient address.\n    error InvalidRecipient(address recipient);\n\n    /// @notice Thrown when supplied native fee is below required fee.\n    /// @param supplied Native value provided by caller.\n    /// @param required Required native fee.\n    error InvalidNativeFee(uint256 supplied, uint256 required);\n\n    /// @notice Thrown when refunding excess native fee to caller fails.\n    /// @param recipient Refund recipient.\n    /// @param amount Refund amount.\n    error NativeRefundFailed(address recipient, uint256 amount);\n\n    /// @notice Thrown when inbound CCIP message unexpectedly carries token amounts.\n    /// @param tokenCount Number of token entries in the payload.\n    error UnsupportedCcipTokenPayload(uint256 tokenCount);\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIPEvents.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeAdapterCCIPEvents {\n    /// @notice Emitted when trusted CCIP peer is configured for a chain selector.\n    /// @param chainSelector CCIP chain selector.\n    /// @param peer Trusted remote adapter identifier bytes.\n    event CcipPeerSet(uint64 indexed chainSelector, bytes peer);\n\n    /// @notice Emitted when CCIP extra arguments are configured for a chain selector.\n    /// @param chainSelector CCIP chain selector.\n    /// @param extraArgs Encoded CCIP execution options.\n    event CcipExtraArgsSet(uint64 indexed chainSelector, bytes extraArgs);\n\n    /// @notice Emitted when an outbound CCIP bridge message is sent.\n    /// @param dstChainSelector Destination CCIP chain selector.\n    /// @param messageId CCIP message identifier.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @param from Source address on this chain.\n    /// @param to Destination recipient address.\n    /// @param amount Bridged token amount.\n    event CcipSend(\n        uint64 indexed dstChainSelector,\n        bytes32 indexed messageId,\n        bytes32 indexed transferId,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /// @notice Emitted when an inbound CCIP message is accepted and bridged in.\n    /// @param srcChainSelector Source CCIP chain selector.\n    /// @param messageId CCIP message identifier.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @param to Destination recipient address on this chain.\n    /// @param amount Bridged token amount.\n    event CcipReceive(\n        uint64 indexed srcChainSelector,\n        bytes32 indexed messageId,\n        bytes32 indexed transferId,\n        address to,\n        uint256 amount\n    );\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIPOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeAdapterCCIPOwnerActions {\n    /// @notice Sets the trusted CCIP peer for a source or destination chain.\n    /// @param chainSelector CCIP chain selector.\n    /// @param peer Trusted remote adapter identifier bytes.\n    function setCcipPeer(uint64 chainSelector, bytes calldata peer) external;\n\n    /// @notice Sets CCIP extra arguments used when sending to a destination chain.\n    /// @param chainSelector CCIP destination chain selector.\n    /// @param extraArgs Encoded CCIP execution options.\n    function setCcipExtraArgs(uint64 chainSelector, bytes calldata extraArgs) external;\n}\n"
    },
    "contracts/interfaces/adapters/IToken6022BridgeAdapterCCIP/IToken6022BridgeAdapterCCIPStates.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { IToken6022BridgeCore } from \"../../IToken6022BridgeCore/IToken6022BridgeCore.sol\";\n\ninterface IToken6022BridgeAdapterCCIPStates {\n    /// @notice Returns the bridge core managed by this adapter.\n    /// @return Bridge core contract.\n    function core() external view returns (IToken6022BridgeCore);\n\n    /// @notice Returns the trusted remote adapter for a CCIP chain selector.\n    /// @param chainSelector CCIP chain selector.\n    /// @return peer Trusted remote adapter identifier bytes.\n    function ccipPeers(uint64 chainSelector) external view returns (bytes memory peer);\n\n    /// @notice Returns CCIP extra arguments configured for destination chain selector.\n    /// @param chainSelector CCIP chain selector.\n    /// @return extraArgs Encoded CCIP execution options.\n    function ccipExtraArgs(uint64 chainSelector) external view returns (bytes memory extraArgs);\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCore.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {IToken6022BridgeCoreErrors} from \"./IToken6022BridgeCoreErrors.sol\";\nimport {IToken6022BridgeCoreEvents} from \"./IToken6022BridgeCoreEvents.sol\";\nimport {IToken6022BridgeCoreStates} from \"./IToken6022BridgeCoreStates.sol\";\nimport {IToken6022BridgeCoreActions} from \"./IToken6022BridgeCoreActions.sol\";\nimport {IToken6022BridgeCoreOwnable} from \"./IToken6022BridgeCoreOwnable.sol\";\n\ninterface IToken6022BridgeCore is\n    IToken6022BridgeCoreErrors,\n    IToken6022BridgeCoreEvents,\n    IToken6022BridgeCoreStates,\n    IToken6022BridgeCoreActions,\n    IToken6022BridgeCoreOwnable\n{\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCoreActions.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeCoreActions {\n    /// @notice Enables or disables a bridge adapter.\n    /// @param adapter Adapter address to update.\n    /// @param enabled Whether the adapter should be authorized.\n    function setAdapter(address adapter, bool enabled) external;\n\n    /// @notice Processes an outbound bridge operation on the current chain.\n    /// @param from Address providing tokens on outbound bridge.\n    /// @param amount Token amount bridged out.\n    /// @param transferId Cross-chain transfer identifier.\n    function bridgeOut(address from, uint256 amount, bytes32 transferId) external;\n\n    /// @notice Processes an inbound bridge operation on the current chain.\n    /// @param to Recipient of bridged tokens.\n    /// @param amount Token amount bridged in.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @param transportId Transport-level message identifier.\n    function bridgeIn(address to, uint256 amount, bytes32 transferId, bytes32 transportId) external;\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCoreErrors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeCoreErrors {\n    /// @notice Thrown when a caller is not an authorized bridge adapter.\n    /// @param caller Unauthorized caller address.\n    error OnlyAdapter(address caller);\n\n    /// @notice Thrown when attempting to configure a zero adapter address.\n    /// @param adapter Invalid adapter address.\n    error InvalidAdapter(address adapter);\n\n    /// @notice Thrown when the bridged amount is zero.\n    error InvalidAmount();\n\n    /// @notice Thrown when a transfer identifier has already been consumed.\n    /// @param transferId Replayed transfer identifier.\n    error TransferReplay(bytes32 transferId);\n\n    /// @notice Thrown when a transport identifier has already been consumed.\n    /// @param transportId Replayed transport identifier.\n    error TransportReplay(bytes32 transportId);\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCoreEvents.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeCoreEvents {\n    /// @notice Emitted when an adapter authorization is updated.\n    /// @param adapter Adapter address.\n    /// @param enabled Whether the adapter is enabled.\n    event AdapterSet(address indexed adapter, bool enabled);\n\n    /// @notice Emitted when an outbound bridge operation is processed.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @param from Source address on this chain.\n    /// @param amount Bridged token amount.\n    event BridgeOut(bytes32 indexed transferId, address indexed from, uint256 amount);\n\n    /// @notice Emitted when an inbound bridge operation is processed.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @param transportId Transport-level message identifier.\n    /// @param to Recipient address on this chain.\n    /// @param amount Bridged token amount.\n    event BridgeIn(bytes32 indexed transferId, bytes32 indexed transportId, address indexed to, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCoreOwnable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeCoreOwnable {\n    function owner() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IToken6022BridgeCore/IToken6022BridgeCoreStates.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\ninterface IToken6022BridgeCoreStates {\n    /// @notice Returns whether an adapter is authorized to call bridge methods.\n    /// @param adapter Adapter address to query.\n    /// @return enabled True when adapter is authorized.\n    function adapters(address adapter) external view returns (bool enabled);\n\n    /// @notice Returns whether an outbound transfer identifier has been consumed.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @return consumed True when the transfer has already been used.\n    function outboundTransfers(bytes32 transferId) external view returns (bool consumed);\n\n    /// @notice Returns whether an inbound transfer identifier has been consumed.\n    /// @param transferId Cross-chain transfer identifier.\n    /// @return consumed True when the transfer has already been used.\n    function inboundTransfers(bytes32 transferId) external view returns (bool consumed);\n\n    /// @notice Returns whether an inbound transport identifier has been consumed.\n    /// @param transportId Transport-level message identifier.\n    /// @return consumed True when the transport identifier has already been used.\n    function inboundTransportIds(bytes32 transportId) external view returns (bool consumed);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}